<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-06-23T10:57:12+08:00</updated><id>/feed.xml</id><title type="html">Silas’s Note</title><subtitle>以正合, 以奇胜</subtitle><entry><title type="html">ChaCha20-Poly1305如何工作, golang示例</title><link href="/jekyll/update/2020/06/23/ChaCha20-Poly1305%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C,-golang%E7%A4%BA%E4%BE%8B.html" rel="alternate" type="text/html" title="ChaCha20-Poly1305如何工作, golang示例" /><published>2020-06-23T10:28:09+08:00</published><updated>2020-06-23T10:28:09+08:00</updated><id>/jekyll/update/2020/06/23/ChaCha20-Poly1305%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C,%20golang%E7%A4%BA%E4%BE%8B</id><content type="html" xml:base="/jekyll/update/2020/06/23/ChaCha20-Poly1305%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C,-golang%E7%A4%BA%E4%BE%8B.html">&lt;p&gt;使用RFC 7539中定义的ChaCha20-Poly1305算法对消息进行加密和解密。&lt;/p&gt;

&lt;p&gt;1.1什么是ChaCha20-Poly1305 ？ 
ChaCha20-Poly1305表示使用Poly1305身份验证器以AEAD模式运行的ChaCha20 （加密和解密算法）。&lt;/p&gt;

&lt;p&gt;1.2什么是AE或AEAD？&lt;/p&gt;

&lt;p&gt;认证加密（AE）和带有关联数据的认证加密（AEAD）是一种加密消息并一起认证加密的形式。&lt;/p&gt;

&lt;p&gt;1.3认证加密意味着什么？ 
确保没有人修改密文（加密的消息），它的工作方式类似于验证文件的SHA或MD5哈希。 
Poly1305生成一个MAC （消息验证码）（128位，16字节），并将其附加到ChaCha20密文（加密的文本）中。 
在解密过程中，该算法检查MAC以确保没有人修改密文。&lt;/p&gt;

&lt;p&gt;1.4 ChaCha20-Poly1305如何工作？ 
ChaCha20加密使用密钥和IV（初始化值，nonce）将明文加密为等长的密文。 
Poly1305生成一个MAC（消息认证码）并将其附加到密文中。 最后，密文和明文的长度不同。&lt;/p&gt;

&lt;p&gt;1.5我可以将同一随机数重用于不同的密钥吗？ 
不可以，每个加密的随机数和密钥都必​​须是唯一的，否则密文会妥协！&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
	“crypto/sha256”
	“fmt”
	“golang.org/x/crypto/chacha20poly1305”
	“os”
)&lt;/p&gt;

&lt;p&gt;func main() {
	pass := “Hello”
	msg := “Pass”
	argCount := len(os.Args[1:])
	if argCount &amp;gt; 0 {
		msg = string(os.Args[1])
	}
	if argCount &amp;gt; 1 {
		pass = string(os.Args[2])
	}
	key := sha256.Sum256([]byte(pass))
	aead, _ := chacha20poly1305.NewX(key[:])
	if pass == “” {
		a := make([]byte, 32)
		copy(key[:32], a[:32])
		aead, _ = chacha20poly1305.NewX(a)
	}
	if msg == “” {
		a := make([]byte, 32)
		msg = string(a)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}
nonce := make([]byte, chacha20poly1305.NonceSizeX)
ciphertext := aead.Seal(nil, nonce, []byte(msg), nil)
plaintext, _ := aead.Open(nil, nonce, ciphertext, nil)
fmt.Printf(&quot;Message:\t%s\n&quot;, msg)
fmt.Printf(&quot;Passphrase:\t%s\n&quot;, pass)
fmt.Printf(&quot;\nKey:\t%x\n&quot;, key)
fmt.Printf(&quot;Nonce:\t%x\n&quot;, nonce)
fmt.Printf(&quot;\nCipher stream:\t%x\n&quot;, ciphertext)
fmt.Printf(&quot;Plain text:\t%s\n&quot;, plaintext) } ---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">使用RFC 7539中定义的ChaCha20-Poly1305算法对消息进行加密和解密。</summary></entry></feed>